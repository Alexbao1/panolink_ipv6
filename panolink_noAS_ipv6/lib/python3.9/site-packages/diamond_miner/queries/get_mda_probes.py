from dataclasses import dataclass

from diamond_miner.defaults import DEFAULT_FAILURE_RATE, UNIVERSE_SUBSET
from diamond_miner.queries.query import LinksQuery, links_table, clusterprobes_table, results_view, group_mapping, links_view
from diamond_miner.typing import IPNetwork


@dataclass(frozen=True)
class GetMDAProbes(LinksQuery):
    adaptive_eps: bool = True
    dminer_lite: bool = True
    target_epsilon: float = DEFAULT_FAILURE_RATE

    def statement(
        self, measurement_id: str, subset: IPNetwork = UNIVERSE_SUBSET
    ) -> str:
        if self.adaptive_eps:
            eps_fragment = """
            arrayMax(links_per_ttl) AS max_links,
            if(max_links == 0, target_epsilon, 1 - exp(log(1 - target_epsilon) / max_links))
                AS epsilon,
            """
        else:
            eps_fragment = """
            target_epsilon AS epsilon,
            """

        if self.dminer_lite:
            dm_fragment = """
            arrayMap(k -> toUInt32(ceil(ln(epsilon / (k + 1)) / ln((k + 1 - 1) / (k + 1)))), links_per_ttl) AS mda_flows,
            """
        else:
            # TODO: Implement by computing Dh(v)
            raise NotImplementedError

        return f"""
        WITH
            {self.target_epsilon} AS target_epsilon,

            groupUniqArray((near_ttl, near_addr, far_addr)) AS links,

            arrayMap(x -> x.1, links) AS links_ttls,

            range(arrayMin(links_ttls), arrayMax(links_ttls) + 2) AS TTLs,

            arrayMap(t -> countEqual(links_ttls, t), TTLs) AS links_per_ttl,

            {eps_fragment}

            {dm_fragment}

            arrayMap(i -> arrayMax([mda_flows[i], mda_flows[i - 1]]), arrayEnumerate(TTLs)) AS cumulative_probes
        SELECT
            probe_protocol,
            cluster_id,
            cumulative_probes,
            TTLs
        FROM (
            SELECT 
                probe_protocol, 
                probe_src_addr, 
                near_addr,
                far_addr,
                probe_dst_addr,
                near_ttl,
                '1' AS cluster_id
            FROM {links_table(measurement_id)}
        )
        GROUP BY (probe_protocol, probe_src_addr, cluster_id)
        """

@dataclass(frozen=True)
class InsertMDAProbes(GetMDAProbes):
    def statement(
        self, measurement_id: str, subset: IPNetwork = UNIVERSE_SUBSET
    ) -> str:
        assert self.round_leq
        return f"""
        INSERT INTO {clusterprobes_table(measurement_id)}
        WITH
            arrayJoin(arrayZip(TTLs, cumulative_probes)) AS ttl_probe
        SELECT
            probe_protocol,
            cluster_id,
            ttl_probe.1,
            ttl_probe.2,
            {self.round_leq + 1}
        FROM ({super().statement(measurement_id, subset)})
        """
