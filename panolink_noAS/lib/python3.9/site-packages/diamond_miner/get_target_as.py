from collections import defaultdict
import copy
from pych_client import ClickHouseClient
from ipaddress import IPv4Network
from diamond_miner.queries.query import Query, results_table,results_view, group_mapping, bgp_table, ttl_filtered_group_mapping
import subprocess

def get_subgraph(client: ClickHouseClient, measurement_id: str):
    # client.json(f"""TRUNCATE TABLE {group_mapping(measurement_id)} """)
    # middle_asns = client.text(f"select distinct asn from {results_table(measurement_id)} where reply_icmp_type = 11 and asn!='-1'").split('\n')
    # middle_asns = client.text(f"select distinct asn from {results_table(measurement_id)} where reply_icmp_type = 11").split('\n')
    middle_asns = client.text(f"select distinct asn from {results_view(measurement_id)}").split('\n')
    for asn in middle_asns:
        edges = client.json(
            f"""WITH SubQuery AS (
                SELECT DISTINCT probe_dst_addr, probe_ttl
                FROM {results_view(measurement_id)}
                WHERE asn = '{asn}'
            )
            , JoinedResults AS (
                SELECT ot.probe_dst_addr, ot.probe_ttl, ot.asn,ot.ip_asn
                FROM {results_view(measurement_id)} AS ot
                ASOF INNER JOIN SubQuery AS sq ON ot.probe_dst_addr = sq.probe_dst_addr AND ot.probe_ttl >= sq.probe_ttl
             --   where ot.asn != '-1'
            )
            , Sequences AS (
                SELECT 
                    probe_dst_addr,
                    arrayConcat(
                        arrayMap(
                            i -> asn_sequence[i], arraySort(i -> ttl_sequence[i], range(1, length(ttl_sequence) + 1))),
                            arraySlice(ip_asn_sequence, -1))  
                    AS asn_sorted_sequence
                FROM (
                    SELECT 
                        probe_dst_addr,
                        groupArray(probe_ttl) as ttl_sequence,
                        groupArray(asn) as asn_sequence,
                        groupArray(ip_asn) as ip_asn_sequence
                    FROM 
                        JoinedResults
                    GROUP BY 
                        probe_dst_addr
                ) 
            )
            SELECT 
                deduped_sequence,
                count(*) as frequency
            FROM (
                SELECT 
                    arrayFilter(i -> (i = 1) OR (asn_sorted_sequence[i] != asn_sorted_sequence[i - 1]), 
                                range(1, length(asn_sorted_sequence)+1)) as filtered_indices,
                    arrayMap(i -> asn_sorted_sequence[i], filtered_indices) as deduped_sequence
                FROM Sequences
            )
            GROUP BY deduped_sequence
            """)
        #construct_subgraph(edges,asn)

        generate_mapping(client, measurement_id, edges, asn)
        

def generate_mapping(client: ClickHouseClient, measurement_id: str,leaf_paths,src_asn):

    
    # leaf_paths = [t['deduped_sequence'] for t in leaf_paths ]
    leaf_paths = [t['deduped_sequence'] for t in leaf_paths if t['frequency'] > 1]
    # print(leaf_paths)
    start_node_to_group = {}
    leaf_to_group = {}
    group_id = 1

    for path in leaf_paths:
        if len(path) < 2:
            leaf_to_group[path[0]] = src_asn + '.' + str(group_id)
            group_id += 1
            continue
        leaf = path[-1]  # 叶子节点是路径的最后一个元素
        # 如果路径长度大于1，则取第二个节点作为起始节点，否则取None
        start_node = path[1] if len(path) > 1 else None  
        if start_node not in start_node_to_group:
            start_node_to_group[start_node] = src_asn + '.' + str(group_id)
            group_id += 1
        
        leaf_to_group[leaf] = start_node_to_group[start_node]
    ret = [f"('{src_asn}', '{k}', '{v}')" for k,v in leaf_to_group.items()]

    def divide_into_segments(lst, n):
        avg = len(lst) // n
        segments = [lst[i * avg: (i + 1) * avg] for i in range(n)]
        if len(lst) % n != 0:
            segments[-1] += lst[n * avg:]
        return segments

    # Divide ret into four segments
    segments = divide_into_segments(ret, 4)
    for seg in segments:
        statement = f"""INSERT INTO {group_mapping(measurement_id)} VALUES """
        statement += ",".join(seg)
        client.json(statement)      

def ttl_filter_group_mapping(client: ClickHouseClient, measurement_id: str):
    client.json(
        f"""
        INSERT INTO {ttl_filtered_group_mapping(measurement_id)} 
        WITH 
            gm AS (
                SELECT * FROM {group_mapping(measurement_id)}
            )
            , result AS (
                SELECT 
                    toIPv6(arrayStringConcat(arraySlice(splitByChar('.', toString(probe_dst_addr)), 1, 3), '.') || '.0') as probe_dst_addr
                    , groupArray((probe_ttl, asn)) as path 
                FROM {results_table(measurement_id)}
                WHERE (splitByChar('.', toString(probe_dst_addr))[4]='0' OR 
                      splitByChar('.', toString(probe_dst_addr))[4]='1' OR 
                      splitByChar('.', toString(probe_dst_addr))[4]='2' ) AND
                      reply_icmp_type=11
                GROUP BY probe_dst_addr
                ORDER BY probe_dst_addr
            )
            , asn2prefixes AS (
                SELECT ip_asn, toIPv6(toString(prefix)) as probe_dst_addr 
                FROM {bgp_table(measurement_id)}
            )
            , asn2path AS (
                SELECT ip_asn, groupArray(path) AS path 
                FROM (
                  SELECT ip_asn, arrayJoin(path) AS path FROM result INNER JOIN asn2prefixes using probe_dst_addr
                )
                GROUP BY ip_asn
            )
        SELECT asn, ip_asn, group_id,arrayFilter(x->x.2=if(splitByChar('.',asn)[4]='0','-1',asn),path) as filtered_path, (arrayMin(arrayMap(x->x.1,filtered_path)),arrayMax(arrayMap(x->x.1,filtered_path))+1) AS valid_ttl_range  FROM gm LEFT JOIN asn2path USING ip_asn
        WHERE valid_ttl_range.1!=0
        """)

## TODO : rewrite this function return candidates only
def calc_weights(client: ClickHouseClient, measurement_id : str, input_prefix : str):
    prefix_ip = IPv4Network(input_prefix)
    entrys = client.json(f"SELECT * FROM bgp__{measurement_id}".replace("-", "_"))
    candidates = defaultdict(list)  
    for entry in entrys:
        curr_prefix = IPv4Network(entry['prefix'] + '/' + str(entry['len']))
        curr_asn = entry['ip_asn']
        if curr_prefix.subnet_of(prefix_ip):
            candidates[curr_asn].append(curr_prefix)
        elif prefix_ip.subnet_of(curr_prefix):
            candidates[curr_asn].append(prefix_ip)
    return candidates




